---

copyright:
  years: 2016, 2017
lastupdated: "2017-02-21"

---

{:shortdesc: .shortdesc}
{:new_window: target="_blank"}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# {{site.data.keyword.openwhisk_short}} 정보

{{site.data.keyword.openwhisk}}는 이벤트 구동 컴퓨팅 플랫폼으로 서버리스(serverless) 컴퓨팅 또는 FaaS(Function as a Service)라고도 하며 이벤트 또는 직접 호출에 대한 응답으로 코드를 실행합니다. 다음 그림은 상위 레벨 {{site.data.keyword.openwhisk}} 아키텍처를 보여줍니다.
{: shortdesc}

![{{site.data.keyword.openwhisk_short}} 아키텍처](./images/OpenWhisk.png)

이벤트 예로는 데이터베이스 레코드에 대한 변경, 특정 온도를 초과하는 IoT 센서 읽기, GitHub 저장소에 대한 새 코드 커미트 또는 웹 또는 모바일 앱으로부터의 단순 HTTP 요청 등이 있습니다. 외부 및 내부 이벤트 소스의 이벤트는 트리거를 채널로 사용하며 규칙은 조치가 이러한 이벤트에 대해 반응하도록 허용합니다.

조치는 JavaScript 또는 Swift 코드의 작은 스니펫이거나 Docker 컨테이너에 임베드된 사용자 정의 바이너리 코드입니다. {{site.data.keyword.openwhisk_short}}의 조치는 트리거가 실행될 때마다 즉시 배치되고 실행됩니다. 더 많은 트리거가 실행될수록 더 많은 조치가 호출됩니다. 트리거가 실행되지 않으면 조치 코드가 실행되지 않으므로 비용이 발생하지 않습니다.

조치를 트리거와 연관시키는 것 외에 {{site.data.keyword.openwhisk_short}} API, CLI 또는 iOS SDK를 사용하여 조치를 직접 호출할 수도 있습니다. 코드를 작성하지 않고 일련의 조치를 체인화할 수 있습니다. 시퀀스 내의 한 조치의 출력이 다음 조치의 입력으로 전달되어 체인 내의 각 조치가 순서대로 호출됩니다.

일반적인 장기 실행 가상 머신 또는 컨테이너를 사용하는 경우, 단일 인스턴스의 가동 중단에 대해 복원할 수 있도록 다중 VM 또는 컨테이너를 배치하는 것이 일반적인 관례입니다. 그러나 {{site.data.keyword.openwhisk_short}}에서는 복원 관련 비용 오버헤드 없이 대체 모델을 제공합니다. 조치의 On-Demand 실행은 실행 중인 조치의 수가 항상 트리거 비율과 일치하도록 내재적인 확장성 및 최적화된 활용도를 제공합니다. 또한 개발자는 이제 기본 서버, 스토리지, 네트워크, 운영 체제 인프라의 모니터링, 패치, 보안에 대해 걱정할 필요 없이 코드에만 집중할 수 있습니다. 

추가 서비스 및 이벤트 제공자와의 통합이 패키지에 추가될 수 있습니다. 패키지는 피드와 조치의 번들입니다. 피드는 트리거 이벤트를 실행하기 위해 외부 이벤트 소스를 구성하는 코드 조작입니다. 예를 들어, Cloudant 변경 피드로 작성된 트리거는 문서가 수정되거나 Cloudant 데이터베이스에 추가될 때마다 트리거를 실행하도록 서비스를 구성합니다. 패키지의 조치는 개발자가 이벤트 소스로 서비스를 사용할 수 있을 뿐 아니라 해당 서비스의 API도 호출할 수 있도록 서비스 제공자가 제공할 수 있는 재사용가능 로직을 나타냅니다. 

패키지의 기존 카탈로그는 유용한 기능으로 애플리케이션을 강화하고 에코시스템 내에서 외부 서비스에 액세스할 수 있는 빠른 방법을 제공합니다. {{site.data.keyword.openwhisk_short}}가 사용 가능한 외부 서비스의 예는 Cloudant, Weather Company, Slack 및 GitHub입니다.


## {{site.data.keyword.openwhisk_short}}의 작동 방식
{: #openwhisk_how}

오픈 소스 프로젝트인 OpenWhisk는 Nginx, Kafka, Consul, Docker, CouchDB를 이용합니다. 이러한 모든 컴포넌트는 함께 “서버리스(serverless) 이벤트 기반 프로그래밍 서비스”를 형성합니다. 모든 컴포넌트를 자세하게 설명하려면 시스템을 통해 조치 호출(발생 시)을 추적합니다. OpenWhisk의 호출은 서버리스(serverless) 엔진이 수행하는 핵심 작업입니다(사용자가 시스템에 공급한 코드 실행 및 실행 결과 리턴).

### 조치 작성

전후 상황에 대한 설명을 위해 먼저 시스템에서 조치를 작성합니다. 시스템을 통해 추적하는 동안 나중에 개념을 설명하기 위해 해당 조치를 사용합니다. 다음 명령에서는 [OpenWhisk CLI가 올바르게 설정되어 있다](https://github.com/openwhisk/openwhisk/tree/master/docs#setting-up-the-openwhisk-cli)고 가정합니다.

먼저 “Hello World”를 stdout으로 인쇄할 다음 코드가 포함된 *action.js* 파일을 작성하고 “hello” 키 아래에 “world”가 포함된 JSON 오브젝트를 리턴합니다.
```javascript
function main() {
    console.log('Hello World');
    return { hello: 'world' };
}
```
{: codeblock}

다음을 사용하여 해당 조치를 작성합니다.
```
wsk action create myAction action.js
```
{: pre}

완료되었습니다. 이제 실제로 해당 조치를 호출할 수 있습니다.
```
wsk action invoke myAction
```
{: pre}

## 처리에 대한 내부 플로우
OpenWhisk에서 실제로 발생하는 상황

![처리에 대한 OpenWhisk 플로우](images/OpenWhisk_flow_of_processing.png)

### 시스템 입력: nginx

먼저 OpenWhisk의 사용자 대면 API는 완전히 HTTP 기반이며 RESTful 디자인을 따릅니다. 그 결과 wsk-CLI로 보낸 명령은 근본적으로 OpenWhisk 시스템에 대한 HTTP 요청입니다. 위의 특정 명령은 다음과 같이 번역됩니다.
```
POST /api/v1/namespaces/$userNamespace/actions/myAction
Host: $openwhiskEndpoint
```
{: screen}

*$userNamespace* 변수에 주의하십시오. 사용자에게 하나 이상의 네임스페이스에 대한 액세스 권한이 있습니다. 간소화를 위해 사용자가 *myAction*이 입력되는 네임스페이스를 소유하고 있다고 가정합니다.

시스템에 대한 첫 번째 시작점은 **nginx**, 즉 “HTTP 및 리버스 프록시 서버”를 거칩니다. 이는 주로 SSL 종료 및 다음 컴포넌트에 대한 적절한 HTTP 호출 전달에 사용됩니다.

### 시스템 입력: 제어기

HTTP 요청에 대해 수행할 작업이 별로 없는 경우 nginx는 이 요청을 OpenWhisk를 통해 다음 컴포넌트인 **제어기**로 전달합니다. 이는 실제 REST API(**Akka** 및 **Spray** 기반)의 스케일 기반 구현이므로 OpenWhisk의 엔티티에 대한 [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) 요청 및 조치(현재 수행하는 작업) 호출을 포함해 사용자가 수행할 수 있는 모든 작업에 대한 인터페이스 역할을 합니다.

제어기는 먼저 사용자가 수행하려는 작업을 명확하게 합니다. 따라서 HTTP 요청에서 사용하는 HTTP 메소드를 기반으로 합니다. 위의 번역에 따라 사용자는 제어기가 **조치 호출**로 번역한 기존 조치에 대한 POST 요청을 실행합니다.

제어기의 중심 역할(즉, 이름)을 고려할 때 다음 모든 단계에 이 역할이 어느 정도 관련됩니다.

### 인증 및 권한 부여: CouchDB

이제 제어기는 사용자가 누구인지(*인증*)와 이 엔티티에 대한 작업을 수행할 수 있는 권한이 있는지(*권한 부여*)를 확인합니다. 요청에 포함된 신임 정보는 **CouchDB** 인스턴스에서 **subjects** 데이터베이스에 대해 확인됩니다.

이 경우 사용자가 OpenWhisk의 데이터베이스에 있고 사용자가 소유한 네임스페이스의 조치라고 가정한 조치 myAction을 호출할 수 있는 권한이 있는지 확인합니다. 후자의 경우 사용자에게 수행하려는 조치를 호출할 수 있는 권한을 효율적으로 제공합니다.

모든 것이 정상적이므로 다음 처리 단계를 수행할 수 있습니다.

### 조치 가져오기: 다시 CouchDB…

제어기가 이제 사용자가 허용되고 조치를 호출할 수 있는 권한을 가졌다고 확인했으므로 실제로 CouchDB의 **whisks**에서 이 조치(이 경우 *myAction*)를 로드합니다.

조치 레코드에는 주로 실행할 코드(위에 표시됨) 및 실제 호출 요청에 포함한 매개변수와 병합된, 조치로 전달할 기본 매개변수가 포함됩니다. 또한 이용할 수 있는 메모리와 같이, 실행 시 부과되는 리소스 제한사항도 포함됩니다.

특히 이 경우 조치가 매개변수를 사용하지 않으므로(함수의 매개변수 정의가 빈 목록임) 기본 매개변수를 설정하지 않고 조치로 특정 매개변수를 보내지 않았다고 가정합니다.

### 조치 호출기 확인: Consul

실제로 코드가 실행되도록 제어기(또는 구체적으로 로드 밸런싱 파트)가 준비되어 있습니다. 하지만 이를 수행할 수 있는 주체를 알아야 합니다. **Consul**, 즉 서비스 검색은 상태를 지속적으로 확인하여 시스템에서 사용 가능한 실행 프로그램을 추적하는 데 사용됩니다. 해당 실행 프로그램은 **호출기**라고 합니다.

이제 사용 가능한 호출기를 알고 있는 제어기가 이 호출기 중 하나를 선택하여 요청된 조치를 호출합니다.

이 경우 시스템에서 3개의 호출기(호출기 0 - 2)가 사용 가능하고 제어기가 *호출기 2*를 선택하여 가까운 조치를 호출한다고 가정합니다.

### 순서 대기: Kafka

이제부터, 전송한 호출 요청에 주로 두 가지 잘못된 상황이 발생할 수 있습니다.

1. 시스템이 충돌하며, 호출이 손실될 수 있습니다.
2. 시스템이 과부하 상태여서 호출은 다른 호출이 먼저 완료되기를 기다려야 합니다.

두 가지 상황에 대한 해답은 **Kafka**, 즉 “처리량이 많은, 분배된 발행-구독 메시징 시스템”입니다. 제어기와 호출기는 Kafka에서 버퍼링되고 지속되는 메시지를 통해서만 통신합니다. 이렇게 하면 시스템이 충돌하는 경우 메시지가 손실되지 않도록 하면서 제어기와 호출기 모두에서 메모리의 버퍼링 부담이 줄어들지만 *OutOfMemoryException* 발생의 위험이 있습니다. 

제어기는 조치를 호출하기 위해 호출할 조치와 해당 조치로 전달할 매개변수(이 경우 없음)가 포함된 메시지를 Kafka에 공개합니다. 이 메시지는 제어기가 Consul로부터 받은 목록에서 선택한 호출기로 전달됩니다.

Kafka가 메시지 수신을 확인하면 사용자에 대한 HTTP 요청에 **ActivationId**로 응답합니다. 사용자는 나중에 이 ID를 사용하여 특정 호출 결과에 액세스할 수 있습니다. 이는 비동기 호출 모델이며 여기서 시스템이 조치 호출에 대한 요청을 허용하면 HTTP 요청이 종료됩니다. 동기 모델(블로킹 호출이라고 함)도 사용 가능하지만 이 문서에서는 다루지 않습니다.

### 실제 코드 호출: 호출기

**호출기**는 OpenWhisk의 핵심입니다. 호출기는 조치를 호출합니다. 또한 Scala로 구현됩니다. 하지만 그보다 더 많은 기능이 있습니다. 개별적이고 안전한 방식으로 조치를 실행하기 위해 **Docker**를 사용합니다.

Docker는 빠르고 개별적이며 제어되는 방식으로 호출하는 각 조치에 대해 자체 캡슐화된 새로운 환경(*컨테이너*라고 함)을 설정하는 데 사용됩니다. nutshell에서 조치 호출마다 Docker 컨테이너가 생성되고, 조치 코드가 삽입되며, 이 코드가 전달된 매개변수를 사용하여 실행되고, 결과가 나타나고, 컨테이너가 영구 삭제됩니다. 또한 이 Docker에서는 성능 최적화가 수행되어 오버헤드가 줄어들고 응답 시간이 짧아집니다. 

특정한 경우 가까이에 있는 조치를 기반으로 한 *Node.js*를 사용하면 호출기가 Node.js 컨테이너를 시작하고, *myAction*에서 코드를 삽입하고, 매개변수 없이 이 코드를 실행하며, 결과를 추출하고, 로그를 저장하고, Node.js 컨테이너를 다시 영구 삭제합니다.

### 결과 저장: 다시 CouchDB

호출기가 결과를 얻으면 이 결과는 위에서 언급된 ActivationId를 사용하여 **whisks** 데이터베이스에 활성화로 저장됩니다. **whisks** 데이터베이스는 **CouchDB**에 있습니다.

특정한 경우 호출기는 조치에서 결과 JSON 오브젝트를 다시 가져오고 Docker에서 작성된 로그를 확보하여 활성화 레코드에 모두 저장하고 이 레코드를 데이터베이스에 저장합니다. 이는 다음과 같이 표시됩니다.

```json
{
   "activationId": "31809ddca6f64cfc9de2937ebd44fbb9",
   "response": {
       "statusCode": 0,
       "result": {
           "hello": "world"
       }
   },
   "end": 1474459415621,
   "logs": [
       "2016-09-21T12:03:35.619234386Z stdout: Hello World"
   ],
   "start": 1474459415595,
}
```
{: codeblock}

레코드에 리턴된 결과 및 작성된 로그를 모두 포함하는 방법에 주목하십시오. 이 레코드에는 조치 호출 시작과 종료 시간도 포함됩니다. 활성화 레코드에 추가 필드가 있으며 이는 간소화를 위해 가장 기본적인 기능만 있는 버전입니다.

이제 REST API를 다시 사용하여(1단계부터 다시 시작) 활성화와 이에 따른 조치 결과를 확보할 수 있습니다. 이렇게 하기 위해 다음을 사용합니다.

```bash
wsk activation get 31809ddca6f64cfc9de2937ebd44fbb9
```
{: pre} 

### 요약

단순 **wsk action invoke myAction**이 {{site.data.keyword.openwhisk_short}} 시스템의 여러 단계를 거치는 방식을 확인했습니다. 시스템 자체는 주로 두 가지 사용자 정의 컴포넌트, 즉 **제어기**와 **호출기**로만 구성됩니다. 여러 사용자가 개발한 모든 것은 이미 오픈 소스 커뮤니티에 있습니다.

다음 주제에서 {{site.data.keyword.openwhisk_short}}에 대한 추가 정보를 찾을 수 있습니다.

* [엔티티 이름](./openwhisk_reference.html#openwhisk_entities)
* [조치 시맨틱](./openwhisk_reference.html#openwhisk_semantics)
* [한계](./openwhisk_reference.md#openwhisk_syslimits)
* [REST API](./openwhisk_reference.md#openwhisk_ref_restapi)
