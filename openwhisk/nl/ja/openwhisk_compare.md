---

copyright:
  years: 2016, 2017
lastupdated: 2017-04-26

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# Function as a Service との比較
{: #openwhisk_faas_compared}

サーバーレス・アーキテクチャーはコンピューティングのすべての問題を解決するわけではありませんが、解決するものもあります。サーバーレス設計が適切な選択となる[多くのユース・ケース](./openwhisk_use_cases.html)があります。ここでは、次のアーキテクチャーを比較します。

1. **Function as a Service (FaaS)** - 管理された OpenWhisk。現在、管理された [OpenWhisk を Bluemix](https://console.ng.bluemix.net/openwhisk) で提供しているベンダーは IBM だけです。

2. **Infrastructure as a Service (IaaS)** で OpenWhisk ユーザー作成プログラム (RYO) を使用。エンド・ユーザーは、Apache Incubation Project から OpenWhisk をダウンロードし、[Bluemix IaaS](https://console.ng.bluemix.net/catalog/?category=devices)、またはその他の [IaaS クラウド](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29)にインストールして実行できます。

3. **Platform as a Service (PaaS)** - 管理されたアプリケーション・ランタイム。IBM Bluemix CloudFoundry 実装で管理された [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java) ランタイムがその実例です。

4. **Container as a Service (CaaS)** - 管理されたコンテナー環境。IBM の [Containers on Bluemix](https://console.ng.bluemix.net/catalog/?category=containerImages) がその実例です。

5. **Infrastructure as a Service (IaaS)** で Java EE ランタイムを使用。IBM の [WebSphere Application Server VM on Bluemix](https://console.ng.bluemix.net/catalog/services/websphere-application-server) がその実例です。

これらの異なるランタイムでアプリケーションを開発して運用する**エンド・ユーザーの観点**から、アーキテクチャーの各選択肢の長所と短所を以下にまとめます。


| トピック | (1) OpenWhisk FaaS | (2) OpenWhisk RYO | (3) PaaS | (4) CaaS | (5) IaaS+Java EE |
| --- | --- | --- | --- | --- | --- |
|	アプリケーション単位	|	単一機能 (通常、JavaScript、Swift、または Docker コンテナーの小さなコード・ブロック)。1 KB 未満でも可能ですが、それより大きくても構いません。通常、数 KB 以下です。	|	列 (1) と同じ	|	使用されるランタイムに応じて異なります。EAR ファイルまたは WAR ファイル、あるいはその他の言語固有のアプリケーション・バンドルの場合があります。通常、サイズは比較的大きくなります。KB であることも、バンドルに多くのサービスがあって MB であることもありますが、単一サービスの小さいものも可能です。	|	Docker コンテナーがデプロイメントの単位です。	|	EAR ファイルまたは WAR ファイルとその他の依存関係を使用したアプリケーション・サーバーを含む VM。通常、GB のサイズです。	|
|	リソースのフットプリント	|	エンド・ユーザーは、メモリー、CPU、その他のリソースについて費用を支払うことも配慮することもありません。アクションに何らかのフットプリントはありますが、ユーザーがそれを心配する必要はありません。	|	大。エンド・ユーザーは必ず IaaS 環境をまずプロビジョンしてから、その上に OpenWhisk をインストールして構成する必要があります。	|	小。エンド・ユーザーはアプリを実行するためのメモリーと CPU について費用を支払いますが、実行中でないアプリについては費用は発生しません。	|	小から中	|	大。エンド・ユーザーは、アプリ実行時に、ディスク・ストレージ、メモリー、CPU、および場合によってはその他のコンポーネントについても費用を支払う必要があります。アプリ停止時には、ストレージ・コストのみが発生します。	|
|	インストールとセットアップ	|	不要。	|	難解。エンド・ユーザーがすべてを行います	|	不要。	|	中程度。ハードウェア、ネットワーキング、OS、コンテナー管理ツールは CaaSs ベンダーが提供し、イメージ、接続、インスタンスはエンド・ユーザーが行います。	|	難解。ハードウェア、ネットワーキング、OS、初期 Java EE インストールはベンダーが提供し、追加の構成、クラスタリング、スケーリングはエンド・ユーザーが行います。	|
|	プロビジョニングの時間	|	ミリ秒	|	列 (4) と (5) を参照	|	分	|	分	|	時間	|
|	稼働中の管理	|	なし	|	難解	|	なし	|	中程度	|	難解	|
|	弾力性に優れたスケーリング	|	各アクションは常に、負荷に応じて即時に固有のスケーリングが行われます。VM および他のリソースの事前プロビジョンは不要です。	|	提供されません。エンド・ユーザーが IaaS でコンピュート・キャパシティーを提供し、VM のスケーリングを管理する必要があります。VM がスケーリングされると、OpenWhisk が自動的にアクションをスケーリングしますが、リソースは事前にプロビジョン済みでなければなりません	|	自動ですが、スケーリングには時間がかかります。ユーザーは、ピークの開始時に何分間かスケーリング・アクションの完了を待つことがあります。自動スケーリングには、入念な調整が必要です。	|	自動ですが、スケーリングには時間がかかります。ユーザーは、ピークの開始時に何分間かスケーリング・アクションの完了を待つことがあります。自動スケーリングには、入念な調整が必要です。	|	提供されません	|
|	キャパシティー・プランニング	|	不要。必要なキャパシティーを FaaS が自動的に提供します	|	事前に十分なキャパシティーをプロビジョンするか、スクリプト化する必要があります。	|	ある程度のキャパシティー・プランニングが必要ですが、ある程度の自動のキャパシティー増強が提供されます	|	ある程度のキャパシティー・プランニングが必要ですが、ある程度の自動のキャパシティー増強が提供されます	|	ピーク・ワークロードの処理に十分なキャパシティーを静的にプロビジョンする必要があります 	|
|	持続的な接続および状態	|	非常に限られます。コンテナー・キャッシングの場合を除き、持続的な接続は保持できません。一般的に、状態は外部リソースで保持される必要があります。	|	列 (1) と同じ	|	サポートされます。オープン・ソケットまたは接続を長時間保持することができ、呼び出し間で状態をメモリーに格納可能です。	|	サポートされます。オープン・ソケットまたは接続を長時間保持することができ、呼び出し間で状態をメモリーに格納可能です。	|	サポートされます。オープン・ソケットまたは接続を長時間保持することができ、呼び出し間で状態をメモリーに格納可能です。	|
|	保守	|	不要。スタック全体が IBM によって管理されます。	|	かなり大。ターゲット環境に応じて、ユーザーによるハードウェア、ネットワーキング、OS、ストレージ、DB のプロビジョン、OpenWhisk のインストールおよび保守などが必要です。	|	不要。スタック全体がベンダーによって管理されます。	|	かなり大。ユーザーがカスタム・イメージの作成と保守、コンテナーのデプロイと管理、コンテナー間の接続の管理などを行う必要があります。	|	かなり大。ユーザーが VM を割り振り、Java EE サーバーを個々に管理してスケーリングする必要があります。	|
|	高可用性 (HA) と災害復旧 (DR)	|	内在 / 追加コストはありません	|	ユーザー作成プログラム (RYO) 	|	利用には、追加料金が必要です。	|	失敗したコンテナーを自動的に再始動することができます。	|	半自動で、利用には追加料金が必要です。VM を自動的にフェイルオーバーすることができます。	|
|	セキュリティー	|	ベンダー提供	|	ユーザー作成プログラム (RYO)	|	RYO とベンダー提供の混合	|	RYO とベンダー提供の混合	|	ユーザー作成プログラム (RYO)	|
|	開発者の速度	|	最高	|	最高	|	最高	|	平均	|	遅い	|
|	リソースの使用状況 (アイドルでも有料のリソース)	|	リソースは、要求があるときにのみ呼び出されるため、アイドルになることはありません。 ワークロードがない場合は、リソースの割り振りはなく、コストも発生しません	|	このオプションは IaaS または CaaS を使用するため、列 (4) および (5) と同様の考慮事項が適用されます。	|	一部のリソースはアイドルである場合があります。自動のスケールアップおよびスケールダウンはアイドル・リソースの除去に役立ちますが、一定数の実行中インスタンスが常時存在する必要があり、これらの使用はキャパシティーの 50 % に満たないことが多くあります。停止済みのインスタンスにコストはかかりません。	|	列 (3) と同様	|	一部のリソースはアイドルである場合があります。自動スケーリングはサポートされません。一定数の実行中インスタンスが常時存在する必要があり、これらの使用はキャパシティーの 50 % に満たないことが多くあります。停止済みのインスタンスに、ストレージのコストが発生する場合があります。	|
|	成熟度	|	低	|	低	|	低	|	中	|	高	|
|	リソースの制限	|	[いくつかの制限があります](./openwhisk_reference.html#openwhisk_syslimits)	|	割り振られたリソース応じて異なります	|	いいえ	|	いいえ	|	いいえ	|
|	使用頻度の低いサービスの待ち時間	|	頻度の低い要求では、初回は何秒かの応答時間がかかることがありますが、その後の要求ではミリ秒の範囲内になります。	|	状況によって異なります。	|	非常に低	|	非常に低	|	非常に低。システムに十分なリソースがあることが前提	|
|	最適なアプリケーション・タイプ	|	イベント処理、IoT、モバイル・バックエンド、マイクロサービス。モノリシック・アプリケーションには明らかに不適です。[ユース・ケース](./openwhisk_use_cases.html)を参照	|	列 (1) と同じですが、ユーザーが 非 IBM クラウドで、またはオンプレミスで実行する必要がある場合です。	|	24 時間 365 日のワークロード負荷を含む Web アプリケーション、接続を長期間オープンにしておく必要があるステートフル・サービス。マイクロサービスまたはモノリシック・アプリケーションの実行に使用できます。	|	マイクロサービス・アプリケーションによく適しています。	|	オンプレミスからクラウドにマイグレーションされた従来型のエンタープライズ・アプリケーション。モノリシック・アプリケーションに適しています。	|
|	課金の細分度と請求処理	|	[100 ミリ秒のブロックごと](https://console.ng.bluemix.net/openwhisk/learn/pricing)	|	実装によって異なります。IaaS または CaaS を使用している場合は、同様の考慮事項が適用されます。列 (4) および (5) を参照	|	通常は、リソース・バンドル (CPU + メモリー + 一定のディスク・スペース) に対して時間単位 (まれに、分単位) で課金されます	|	列 (3) と同様	|	列 (3) と同様	|
|	総所有コスト (TCO)	|	優位点として、その他の場合と比較し、アプリケーションのコストを桁違いに抑えられる可能性があります。リソースは自動スケーリングされるため、オーバープロビジョンの問題が発生することはありません	|	クラウド・デプロイメントでは、OpenWhisk FaaS よりコストが高くなる可能性が大きいですが、オンプレミス・デプロイメントでは、従来型のアーキテクチャーより安くなる可能性があります。	|	比較的低くなります。ユーザーはリソースのプロビジョンや管理を行う必要はなく、自分のアプリケーションについて考えるだけです。ただし、サーバーレスと比べて一定レベルのオーバープロビジョンが発生します	|	中程度。ユーザーはコンテナーおよびアプリケーションをプロビジョンして管理する必要がありますが、サーバーレスおよび PaaS と比べて一定レベルのオーバープロビジョンが発生します	|	比較的高くなりますが、レガシー・アプリケーションのクラウド・ネイティブ・モデルへのマイグレーションが極めて高価になることを考えると、そうしたアプリに対して実現可能で経済的な選択肢であるかもしれません	|
