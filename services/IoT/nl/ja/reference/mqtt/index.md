---

copyright:
  years: 2015, 2016, 2017
lastupdated: "2016-11-18"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}

# MQTT メッセージング
{: #ref-mqtt}

MQTT は、デバイスとアプリケーションが {{site.data.keyword.iot_full}} と通信するために使用する主要なプロトコルです。MQTT は、パブリッシュ/サブスクライブ・メッセージング・トランスポート・プロトコルで、センサーとモバイル・デバイスの間でリアルタイム・データを効率的に交換するために設計されています。
{:shortdesc}

MQTT は TCP/IP で実行されます。TCP/IP の直接コーディングも可能ですが、MQTT プロトコルの詳細を処理するライブラリーを使用することもできます。広範囲の MQTT クライアント・ライブラリーが用意されています。IBM は、いくつかのクライアント・ライブラリーの開発やサポートに寄与しています。それには以下のサイトで利用可能なものが含まれます。

- [MQTT コミュニティー Wiki](https://github.com/mqtt/mqtt.github.io/wiki)
- [Eclipse Paho プロジェクト](http://eclipse.org/paho/)

## バージョン・サポート
{: #version-support}
{{site.data.keyword.iot_short_notm}} でサポートされる MQTT のバージョンについては、[標準と要件](../standards_and_requirements.html#mqtt)を参照してください。

## アプリケーション、デバイス、ゲートウェイの各クライアント
{: #device-app-clients}

{{site.data.keyword.iot_short_notm}} において、モノの主要なクラスはデバイスとアプリケーションです。ゲートウェイは、デバイスのサブクラスです。

MQTT クライアントは、モノのクラスとして自身の情報を {{site.data.keyword.iot_short_notm}} サービスに提供します。そのモノのクラスによって、クライアントの機能が接続時に決まります。さらにモノのクラスにより、クライアント認証のメカニズムも決まります。

アプリケーションとデバイスは、別々の MQTT トピック・スペースで動作します。デバイスはデバイス・スコープのトピック・スペース内で動作する一方、アプリケーションには組織全体のトピック・スペースに対して全アクセス権限が付与されます。詳しくは、以下のトピックを参照してください。

- [デバイス用の MQTT メッセージング](../../devices/mqtt.html)
- [アプリケーション用の MQTT メッセージング](../../applications/mqtt.html)
- [ゲートウェイ用の MQTT メッセージング](../../gateways/mqtt.html)

### 保存メッセージ
{{site.data.keyword.iot_short_notm}} には、MQTT メッセージングの保存メッセージ・フィーチャーに対する制限付きサポートが用意されています。デバイス、ゲートウェイ、またはアプリケーションから {{site.data.keyword.iot_short_notm}} へ送信される MQTT メッセージで保存メッセージ・フラグが true に設定されている場合、メッセージは未保存メッセージとして処理されます。{{site.data.keyword.iot_short_notm}} の組織は、保存メッセージをパブリッシュする権限を持っていません。{{site.data.keyword.iot_short_notm}}サービスは、保存メッセージのフラグが true に設定されている場合でもそのフラグをオーバーライドし、そのフラグが false に設定されている場合と同じ要領でメッセージを処理します。

## サービス品質のレベル
{: #qos-levels}

MQTT プロトコルでは、クライアントとサーバーの間のメッセージ配信について、「最高 1 回」、「最低 1 回」、そして「ちょうど 1 回」の 3 つのサービス品質が提供されています。
イベントとコマンドの送信では任意のサービス品質レベルを使用できますが、実際のニーズに合った適切なサービス・レベルとは何かを注意深く考慮する必要があります。必ずしも、サービス品質レベル 2 がレベル 0 よりも優れたオプションであるわけではありません。

### 最高 1 回 (QoS0)

「最高 1 回」サービス品質レベル (QoS0) は、転送の最高速モードであり、「応答不要送信」とも呼ばれます。メッセージは最高 1 回配信されるか、あるいはまったく配信されません。ネットワークを通じての配信には肯定応答が送られず、メッセージは保管されません。クライアントが切断されるか、サーバーで障害が発生すると、メッセージが失われる可能性があります。

MQTT プロトコルでは、サーバーからクライアントへのパブリッシュをサービス品質レベル 0 で転送する必要はありません。サーバーがパブリケーションを受信した時点でクライアントが切断されていた場合、サーバーの実装方法によってはパブリケーションが破棄されることがあります。

**ヒント:** リアルタイム・データを一定の間隔で送信する場合は、サービス品質レベル 0 を使用します。1 つのメッセージが欠落しても、直後にそれより新しいデータが含まれる別のメッセージが送信されるため、実際には問題になりません。このシナリオの場合、高いサービス品質を使用することに余分のコストをかけても、それほどメリットはありません。

### 最低 1 回 (QoS1)

サービス品質レベル 1 (QoS1) の場合、メッセージは少なくとも 1 回は常に配信されます。送信元が確認応答を受け取るより前に障害が発生した場合、メッセージを複数回配信できます。メッセージがパブリッシュされたという受信側の確認を送信側が受信する時点まで、メッセージは送信側にローカルに保管されていなければなりません。メッセージが保管されるのは、メッセージの再送が必要になった場合に備えてのことです。

### ちょうど 1 回 (QoS2)

「ちょうど 1 回」のサービス品質レベル 2 (QoS2) は、最も確実ですが、最も転送速度が遅いモードです。メッセージは常にちょうど 1 回配信され、受信側によりメッセージがパブリッシュされたという確認を送信側が受信するまで送信元にもローカルに保管されなければなりません。メッセージが保管されるのは、メッセージの再送が必要になった場合に備えてのことです。サービス品質レベル 2 では、レベル 1 の場合より高度なハンドシェークと確認応答のシーケンスが使用され、メッセージの重複がないことが保証されます。

**ヒント:** コマンドを送信する際、指定されたコマンドのみアクションが実行されること、さらにそのアクションが 1 回のみであることの確認を受け取るには、サービス品質レベル 2 を使用します。これは、レベル 2 には付加的なオーバーヘッドがあっても他のレベルよりメリットがある場合の一例です。

## サブスクリプション・バッファーとクリーン・セッション
{: #subscription-buffers-and-clean-session}

デバイスまたはアプリケーションのいずれかからの各サブスクリプションには、5000 個のメッセージが入るバッファーが割り振られます。そのバッファーがあるので、アプリケーションやデバイスでライブ・データの処理が遅れても問題とはならず、サブスクリプションごとに保留メッセージが 5000 個まで入るバックログを構成することも可能になります。バッファーがいっぱいになった後、さらに新しいメッセージを受信すると、最も古いメッセージから破棄されます。

MQTT クリーン・セッション・オプションは、サブスクリプション・バッファーにアクセスするために使用します。クリーン・セッションが false に設定されている場合、サブスクライバーはバッファーからのメッセージを受信します。クリーン・セッションが true に設定されている場合、バッファーがリセットされます。

**注:** サブスクリプション・バッファー制限は、使用されるサービス品質の設定には関係なく適用されます。アプリケーションがサブスクリプションのメッセージ速度について行けない場合、レベル 1 または 2 で送信されるメッセージをアプリケーションに配信できない場合があります。

## メッセージ・ペイロードの制限
{: #message-payload}

{{site.data.keyword.iot_short_notm}} では、MQTT 規格で許可される任意の形式のメッセージの送受信がサポートされています。MQTT はデータの内容には関与しないため、画像、任意のエンコード方式のテキスト、暗号化データ、そして事実上あらゆるタイプのバイナリー形式データを送ることが可能です。しかし、特定のユース・ケースではいくつかの制限があります。   

また、{{site.data.keyword.iot_short_notm}} におけるメッセージ・ペイロードにはサイズの制限もあります。

### メッセージ・ペイロードのフォーマットの制限

メッセージ・ペイロードには有効な任意のストリングを含めることができますが、JSON (「json」)、テキスト (「text」)、そしてバイナリー (「bin」) フォーマットは、その他のフォーマット・タイプに比べて特に広く使用されます。

さまざまなフォーマット・タイプでのメッセージ・ペイロードの制限の概要を、以下の表に示します。

ペイロード・フォーマット  | 特定のユース・ケースでのガイドライン
--------- | ----------  
JSON | JSON は、{{site.data.keyword.iot_short_notm}} の標準形式です。組み込みの {{site.data.keyword.iot_short_notm}} ダッシュボード、ボードとカード、分析を使用する予定の場合、メッセージ・ペイロードのフォーマットが整形式 JSON テキストに準拠するようにしてください。
テキスト | 有効な UTF-8 文字エンコードを使用します。
バイナリー | 制限はありません。


### メッセージ・ペイロードの最大サイズ

**重要:** {{site.data.keyword.iot_short_notm}} のペイロードの最大サイズは、131072 バイトです。ペイロードがその制限を超えるメッセージは拒否されます。接続しているクライアントも切断され、以下のデバイス・メッセージの例に示されているようなメッセージが診断ログに表示されます。

`x.x.x.x からの接続が閉じられました。メッセージ・サイズがこのエンドポイントには大きすぎます。`

## MQTT キープアライブ間隔
{: #mqtt-keep-alive}

MQTT キープアライブ間隔では、クライアントとブローカーの間の通信がない状態を許容する最大時間を秒単位で定義します。MQTT クライアントは、ブローカーとの通信が他に何もない場合には PINGREQ パケットを送信しなければなりません。キープアライブ間隔を設定すると、クライアントとブローカーの両方がネットワークの障害を検出できるので、TCP/IP タイムアウト期間に達するまで待たずに接続を破棄できます。

{{site.data.keyword.iot_short_notm}} MQTT クライアントが共有サブスクリプションを使用している場合は、キープアライブ間隔の値を 1 秒から 3600 秒の間に設定しなければなりません。0 の値や 3600 より大きい値を要求すると、{{site.data.keyword.iot_short_notm}} ブローカーによってキープアライブ間隔が 3600 秒に設定されます。
