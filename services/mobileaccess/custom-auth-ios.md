---

copyright:
  years: 2015, 2016
lastupdated: "2016-10-27"

---

# Configuring {{site.data.keyword.amashort}} client SDK for iOS (Objective-C)
{: #custom-ios}


Configure your iOS application that is using custom authentication to use the {{site.data.keyword.amafull}} client SDK and connect your application to {{site.data.keyword.Bluemix}}.

**Note:** If you are developing your iOS app in Swift, consider using the {{site.data.keyword.amashort}} client Swift SDK. The instructions on this page apply to the {{site.data.keyword.amashort}} client Objective-C SDK. For instructions on using the new Swift SDK, see [Configuring {{site.data.keyword.amashort}} client SDK for iOS (Swift SDK)](https://console.{DomainName}/docs/services/mobileaccess/custom-auth-ios-swift-sdk.html).

## Before you begin
{: #before-you-begin}
You must have:

* A resource that is protected by an instance of the {{site.data.keyword.amashort}} service that is configured to use a custom identity provider.  
* Your **TenantID** value. Open your service in the  {{site.data.keyword.amashort}} dashboard. Click the **Mobile Options** button. The `tenantId` (also known as `appGUID`)  value is displayed in the **App GUID / TenantId** field. You will need this value for intializing the Authorization Manager.
* Your **Realm** name. This is the value you you specificed in the **Realm Name** field of the **Custom** section in the **Management** tab of the {{site.data.keyword.amashort}} dashboard (see [Configuring custom authentication](https://console.stage1.ng.bluemix.net/docs/services/mobileaccess/custom-auth-config-mca.html)).
* The URL of your back-end application (**App Route**). You will need this values for sending requests to the protected endpoints of your back-end application.
* Your {{site.data.keyword.Bluemix_notm}} **Region**. You can find your current {{site.data.keyword.Bluemix_notm}} region in the header, next to the **Avatar** icon ![Avatar icon](images/face.jpg "Avatar icon"). The region value that appears should be one of the following: `US South`, `United Kingdom`, or `Sydney`, and correspond to the SDK values required in the WebView Javascript code: `BMSClient.REGION_US_SOUTH`, `BMSClient.REGION_SYDNEY`, or `BMSClient.REGION_UK`. You will need this value for initializing the {{site.data.keyword.amashort}} client.

For more information, see the following information:
 * [Getting started with {{site.data.keyword.amashort}}](https://console.{DomainName}/docs/services/mobileaccess/getting-started.html)
 * [Setting up the iOS Objective-C SDK](https://console.{DomainName}/docs/services/mobileaccess/getting-started-ios.html)
 * [Using a custom identity provider](https://console.{DomainName}/docs/services/mobileaccess/custom-auth.html)
 * [Creating a custom identity provider](https://console.{DomainName}/docs/services/mobileaccess/custom-auth-identity-provider.html)
 * [Configuring {{site.data.keyword.amashort}} for custom authentication](https://console.{DomainName}/docs/services/mobileaccess/custom-auth-config-mca.html)


## Installing the client SDK with CocoaPods
{: #custom-ios-sdk-cocoapods}
Use the CocoaPods dependency manager to install the {{site.data.keyword.amashort}} client SDK.

1. Open Terminal and navigate to the root directory of your iOS project.

1. Edit the `Podfile` and add the following line.

	```
	pod 'IMFCore'
	```

1. From the command line, run `pod install`.
CocoaPods installs added dependencies. The progress and which components were added are displayed.

    **Important**: You must now open your project by using a xcworkspace file that was generated by CocoaPods. Usually the name is `{your-project-name}.xcworkspace`.

1. Run `open {your-project-name}.xcworkspace` from command line to open your iOS project workspace.



### Initializing the client SDK
{: #custom-ios-sdk-initialize}

Initialize the SDK by passing the application route (`applicationRoute`) and GUID (`applicationGUID`) parameters. A common, though not mandatory, place to put the initialization code is in the `application:didFinishLaunchingWithOptions` method of your application delegate

1. Get your application parameter values. Open your app in the {{site.data.keyword.Bluemix_notm}} dashboard. Click **Mobile Options** to see the values for **Route** (`applicationRoute`) and **App GUID** (`applicationGUID`).

1. Import the `IMFCore` framework in the class that you want to use client SDK.

	Objective-C:

	```Objective-C
	#import <IMFCore/IMFCore.h>
	```

	Swift:

	The {{site.data.keyword.amashort}} client SDK is implemented with Objective-C. You might need to add a bridging header to your Swift project to use the SDK.

	* Right-click your project in Xcode and select **New File...**
	* In the **iOS Source** category, pick **Header file**. Name the file `BridgingHeader.h`.
	* Add `#import <IMFCore/IMFCore.h>` to your bridging header.
	* Click your project in Xcode and select **Build Settings** tab.
	* Search for `Objective-C Bridging Header`.
	* Set the value to location of your `BridgingHeader.h` file, for example: `$(SRCROOT)/MyApp/BridgingHeader.h`
	* Verify that your bridging header is being picked up by Xcode by building your project.

1. Initialize the client SDK. Replace the applicationRoute and applicationGUID with the values for **Route** (`applicationRoute`) and **App GUID** (`applicationGUID`) that you obtained from **Mobile Options**.

	Objective-C:

	```Objective-C
	[[IMFClient sharedInstance]
			initializeWithBackendRoute:@"applicationRoute"
			backendGUID:@"applicationGUID"];
	```

	Swift:

	```Swift
	IMFClient.sharedInstance().initializeWithBackendRoute("applicationRoute",
	 							backendGUID: "applicationGUID")
	```

## Initializing the AuthorizationManager
Initialize the AuthorizationManager by passing the {{site.data.keyword.amashort}} service `tenantId` parameter. You can find this value by clicking the **Show Credentials** button on the {{site.data.keyword.amashort}} service tile.


### Objective-C:

```Objective-
 [[IMFAuthorizationManager sharedInstance]  initializeWithTenantId: @"tenantId"];
```

### Swift:

```Swift
 IMFAuthorizationManager.sharedInstance().initializeWithTenantId("tenantId")
```


## IMFAuthenticationHandler delegate
{: #custom-ios-sdk-authhandler}


The {{site.data.keyword.amashort}} client SDK provides the `IMFAuthenticationHandler` interface to implement a custom authentication flow. The `IMFAuthenticationHandler` exposes three methods that are called on different phases of the authentication process.

```
- (void)authenticationContext:(id<IMFAuthenticationContext>)context
 						didReceiveAuthenticationChallenge:(NSDictionary*)challenge;
```

This method is called when a custom authentication challenge is received from {{site.data.keyword.amashort}} Service. The arguments include

* `IMFAuthenticationContext` protocol is provided by {{site.data.keyword.amashort}} client SDK so that developer can report back authentication challenge answers or failure during crendtials collection (e.g. user cancelled)
* `NSDictionary` containing a custom authentication challenge as returned by a Custom Identity Provider

By calling the `authenticationContext:didReceiveAuthenticationChallenge` method, the {{site.data.keyword.amashort}} client SDK is delegating control to the developer and putting itself into a waiting-for-credentials mode. It is the responsibility of the developer to collect credentials and report them back to the {{site.data.keyword.amashort}} client SDK by using one of the following `IMFAuthenticationContext` protocol methods:

```
- (void)authenticationContext:(id<IMFAuthenticationContext>)context
						didReceiveAuthenticationSuccess:(NSDictionary *)userInfo;
```

This method is called after a successful authentication. The arguments include `IMFAuthenticationContext` and an optional `NSDictionary` that contains extended information about authentication success.

```
- (void)authenticationContext:(id<IMFAuthenticationContext>)context
						didReceiveAuthenticationFailure:(NSDictionary*)userInfo;
```

This method is called after authentication failure. The arguments include `IMFAuthenticationContext` and an optional `NSDictionary` that contains extended information about authentication failure.

## IMFAuthenticationContext protocol
{: #custom-ios-sdk-authcontext}


The `IMFAuthenticationContext` protocol is supplied as an argument to the `authenticationContext:didReceiveAuthenticationChallenge` method of a custom `IMFAuthenticationHandler`. It is the responsibility of the developer to collect credentials and use `IMFAuthenticationContext` methods to either return credentials to {{site.data.keyword.amashort}} client SDK or report a failure. 
```
-(void) submitAuthenticationChallengeAnswer:(NSDictionary*) answer;

-(void) submitAuthenticationFailure:(NSDictionary*) userInfo;
```

## Sample implementation of a custom IMFAuthenticationDelegate
{: #custom-ios-sdk-sample}


The IMFAuthenticationDelegate sample is designed to work with the custom identity provider sample. You can download the sample from the [GitHub repository](https://github.com/ibm-bluemix-mobile-services/bms-mca-custom-identity-provider-sample).

Objective-C:

``` Objective-C
CustomAuthenticationDelegate.h
-----------------------------------
#import <Foundation/Foundation.h>

@import IMFCore;
@interface CustomAuthenticationDelegate : NSObject <IMFAuthenticationDelegate>
@end


CustomAuthenticationDelegate.m
-----------------------------------
#import "CustomAuthenticationDelegate.h"

@implementation CustomAuthenticationDelegate

-(void)authenticationContext:(id<IMFAuthenticationContext>)context
					didReceiveAuthenticationChallenge:(NSDictionary *)challenge{

	NSLog(@"didReceiveAuthenticationChallenge :: %@", challenge);

	// In this sample, the IMFAuthenticationDelegate immediately returns a hardcoded
	// set of credentials. In a real life scenario, a developer would
	// show a login screen, collect credentials and invoke the
	// [context submitAuthenticationChallengeAnswer:] API

	NSDictionary *challengeAnswer = [NSDictionary dictionaryWithObjectsAndKeys:
									 @"john.lennon", @"username",
									 @"12345", @"password", nil];

	[context submitAuthenticationChallengeAnswer:challengeAnswer];

	// In case there is a failure collecting credentials, report
	// the failure to IMFAuthenticationContext. Otherwise, the Mobile Client
	// Access client SDK remains in a waiting-for-credentials state
	// forever
}

-(void)authenticationContext:(id<IMFAuthenticationContext>)context
					didReceiveAuthenticationSuccess:(NSDictionary *)userInfo{
	NSLog(@"didReceiveAuthenticationSuccess");


}

-(void)authenticationContext:(id<IMFAuthenticationContext>)context
					didReceiveAuthenticationFailure:(NSDictionary *)userInfo{
	NSLog(@"didReceiveAuthenticationFailure");

}

@end
```

Swift implementation:

```Swift
import Foundation

class CustomAuthenticationDelegate : NSObject, IMFAuthenticationDelegate{

	func authenticationContext(context: IMFAuthenticationContext!,
					didReceiveAuthenticationChallenge challenge: [NSObject : AnyObject]!) {

		NSLog("didReceiveAuthenticationChallenge :: %@", challenge)

		// In this sample, the IMFAuthenticationDelegate immediately returns a hardcoded
		// set of credentials. In a real life scenario a developer would
		// show a login screen, collect credentials and invoke the
		// context.submitAuthenticationChallengeAnswer() API

		let challengeAnswer: [String:String] = [
			"username":"john.lennon",
			"password":"12345"
		]

		context.submitAuthenticationChallengeAnswer(challengeAnswer)

		// In case there is a failure collecting credentials, report
		// it back to IMFAuthenticationContext. Otherwise, the Mobile Client
		// Access client SDK remains in a waiting-for-credentials state
		// forever
	}


	func authenticationContext(context: IMFAuthenticationContext!,
					didReceiveAuthenticationSuccess userInfo: [NSObject : AnyObject]!) {
		NSLog("didReceiveAuthenticationSuccess")
	}

	func authenticationContext(context: IMFAuthenticationContext!,
					didReceiveAuthenticationFailure userInfo: [NSObject : AnyObject]!) {
		NSLog("didReceiveAuthenticationFailure")
	}
}
```

## Registering custom IMFAuthenticationDelegate

After you create a custom `IMFAuthenticationDelegate`, register with `IMFClient`. Call the following code in your application before you send any requests to your protected resources. Use the `realmName` that you specified in the {{site.data.keyword.amashort}} dashboard.

Objective-C applications:

```Objective-C
[[IMFClient sharedInstance]
				registerAuthenticationDelegate:[CustomAuthenticationDelegate new]
										forRealm:realmName];
```

Swift applications:
```Swift
IMFClient.sharedInstance().registerAuthenticationDelegate(CustomAuthenticationDelegate(),
									forRealm: realmName)
```


## Testing the authentication
{: #custom-ios-testing}
After you initialize the client SDK and register a custom `IMFAuthenticationDelegate`, you can start making requests to your mobile back-end application.

### Before you begin
{: #custom-ios-testing-before}
 You must have an application that was created with the {{site.data.keyword.mobilefirstbp}} boilerplate and have a resource that is protected by {{site.data.keyword.amashort}} at the `/protected` endpoint.

1. Send a request to protected endpoint of your mobile back-end application in your browser by opening `{applicationRoute}/protected`, for example `http://my-mobile-backend.mybluemix.net/protected`.
  The `/protected` endpoint of a mobile back-end application that is created with the {{site.data.keyword.mobilefirstbp}} boilerplate is protected with {{site.data.keyword.amashort}}. The endpoint can  be accessed by only mobile applications that are instrumented with the {{site.data.keyword.amashort}} client SDK. As a result, an `Unauthorized` message displays in your browser.
1. Use your iOS application to make request to the same endpoint. Add the following code after you initialize `BMSClient` and register your custom `IMFAuthenticationDelegate`:

	Objective-C:

	```Objective-C
	NSString *requestPath = [NSString stringWithFormat:@"%@/protected",
								[[IMFClient sharedInstance] backendRoute]];

	IMFResourceRequest *request =  [IMFResourceRequest requestWithPath:requestPath
																method:@"GET"];

	[request sendWithCompletionHandler:^(IMFResponse *response, NSError *error) {
		if (error){
			NSLog(@"Error :: %@", [error description]);
		} else {
			NSLog(@"Response :: %@", [response responseText]);
			NSLog(@"%@", [[IMFAuthorizationManager sharedInstance] userIdentity]);
		}
	}];
	```

	Swift:

	```Swift
	let requestPath = IMFClient.sharedInstance().backendRoute + "/protected"

	let request = IMFResourceRequest(path: requestPath, method: "GET");
	request.sendWithCompletionHandler { (response, error) -> Void in
		if (nil != error){
			NSLog("Error :: %@", error.description)
		} else {
			NSLog("Response :: %@", response.responseText)
			NSLog("%@", IMFAuthorizationManager.sharedInstance().userIdentity)
		}
	};

	```
1. 	When your requests succeeds, you see the following output in the Xcode console:

	![image](images/ios-custom-login-success.png)

	You can also add logout functionality by adding the following code:

	Objective C:

	```Objective-C
	[[IMFAuthorizationManager sharedInstance] logout : callBack]
	```

	Swift:

	```Swift
	IMFAuthorizationManager.sharedInstance().logout(callBack)
	```

 If you call this code after a user is logged in, the user is logged out. When the user tries to log in again, they must answer the challenge received from the server again.

 Passing `callBack` to the logout function is optional. You can also passÂ `nil`.
